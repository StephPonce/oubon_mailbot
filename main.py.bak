# main.py  — Oubon MailBot

from __future__ import annotations

import base64
import json
import os
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

from fastapi import Depends, FastAPI
from fastapi.responses import RedirectResponse
from pydantic import BaseModel

from app.ai_reply import draft_reply
from app.db import init_db
from app.gmail_client import GmailClient
from app.rules import classify_message, get_rule_for_tags  # used by /rules/preview
from app.settings import Settings, get_settings


# -------------------------------------------------------------------
# App + shared helpers
# -------------------------------------------------------------------

app = FastAPI(title="Oubon MailBot", version="0.1.0")


def get_gmail_client() -> GmailClient:
    """Consistent way to construct a Gmail client with current settings."""
    return GmailClient(Settings())


def _svc(gc: GmailClient):
    """
    Return the Gmail API service regardless of whether the client exposes
    _service(), service(), or a service property.
    """
    cand = getattr(gc, "_service", None)
    if callable(cand):
        return cand()
    cand = getattr(gc, "service", None)
    return cand() if callable(cand) else cand


# -------------------------------------------------------------------
# Startup / health
# -------------------------------------------------------------------

@app.on_event("startup")
async def startup_event():
    await init_db()


@app.get("/health")
async def health():
    return {"status": "ok"}


# -------------------------------------------------------------------
# OAuth (if/when you need to re-authorize)
# -------------------------------------------------------------------

@app.get("/auth/url")
def auth_url(settings: Settings = Depends(get_settings)):
    gc = GmailClient(settings)
    url = gc.build_auth_url()
    return {"auth_url": url}


@app.get("/oauth2callback")
def oauth_callback(code: str, settings: Settings = Depends(get_settings)):
    gc = GmailClient(settings)
    gc.exchange_code_for_tokens(code)
    return RedirectResponse(url="/docs")


# -------------------------------------------------------------------
# Simple ingest / send demo
# -------------------------------------------------------------------

class IngestRequest(BaseModel):
    max_results: int = 5


@app.post("/gmail/ingest")
def gmail_ingest(req: IngestRequest, settings: Settings = Depends(get_settings)):
    gc = GmailClient(settings)
    threads = gc.fetch_threads(max_results=req.max_results)
    return {"ingested_threads": len(threads)}


class SendRequest(BaseModel):
    to: str
    subject: str
    body: str


@app.post("/gmail/send-demo")
def gmail_send_demo(req: SendRequest, settings: Settings = Depends(get_settings)):
    gc = GmailClient(settings)
    gc.send_simple_email(to=req.to, subject=req.subject, body=req.body)
    return {"status": "sent"}


# -------------------------------------------------------------------
# Data files (rules/templates)
# -------------------------------------------------------------------

DATA_DIR = Path("data")
DATA_DIR.mkdir(parents=True, exist_ok=True)

RULES_PATH = DATA_DIR / "rules.json"
TPL_PATH = DATA_DIR / "templates.json"


class RuleItem(BaseModel):
    if_any: List[str]
    apply_label: str
    auto_reply_template: Optional[str] = None
    auto_reply: Optional[bool] = None  # optional explicit flag


class RulesPayload(BaseModel):
    rules: List[RuleItem]


class TemplatePayload(BaseModel):
    id: str
    subject: str
    body: str


DEFAULT_RULES: Dict[str, Any] = {
    "rules": [
        {
            "if_any": ["refund", "return", "broken", "damaged", "warranty", "angry", "complaint"],
            "apply_label": "Support",
            "auto_reply_template": "support_default",
            "auto_reply": True,
        },
        {
            "if_any": [
                "order", "package", "delivery", "tracking", "shipment",
                "arrived", "missing", "unreceived", "not received", "not arrived", "delayed"
            ],
            "apply_label": "Orders",
            "auto_reply_template": "order_missing",
            "auto_reply": True,
        },
        {
            "if_any": ["press", "investor", "wholesale", "partnership"],
            "apply_label": "VIP",
        },
        {
            "if_any": ["mailer-daemon", "delivery status notification", "failure notice", "postmaster", "no-reply", "do-not-reply"],
            "apply_label": "Admin",  # bounce/robot mail — do not auto-reply
        },
    ]
}

DEFAULT_TPLS: Dict[str, Any] = {
    "support_default": {
        "subject": "We received your message",
        "body": (
            "<p>Hi there,</p>"
            "<p>We’ve received your message and opened a ticket (#{{ticket_id}}). "
            "A team member will reply within 1 business day.</p>"
            "<p>— <b>Oubon Support</b></p>"
        ),
    },
    "order_missing": {
        "subject": "We’re on it – order {{ticket_id}}",
        "body": (
            "<p>Hi {{name}},</p>"
            "<p>Sorry your package hasn’t arrived. Please reply with your order number "
            "and we’ll investigate right away.</p>"
            "<p>— Oubon Support</p>"
        ),
    },
}


def _load_rules() -> Dict[str, Any]:
    if RULES_PATH.exists():
        return json.loads(RULES_PATH.read_text(encoding="utf-8"))
    return DEFAULT_RULES


def _save_rules(data: Dict[str, Any]) -> None:
    RULES_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")


def _load_templates() -> Dict[str, Any]:
    if TPL_PATH.exists():
        return json.loads(TPL_PATH.read_text(encoding="utf-8"))
    return DEFAULT_TPLS


def _save_templates(data: Dict[str, Any]) -> None:
    TPL_PATH.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")


# -------------------------------------------------------------------
# Templates + Rules endpoints
# -------------------------------------------------------------------

@app.post("/templates/upsert")
def templates_upsert(payload: TemplatePayload):
    tpls = _load_templates()
    tpls[payload.id] = {"subject": payload.subject, "body": payload.body}
    _save_templates(tpls)
    return {"saved": payload.id}


@app.get("/templates/list")
def templates_list():
    return _load_templates()


@app.post("/rules/set")
def set_rules(payload: RulesPayload):
    data = {"rules": [r.dict() for r in payload.rules]}
    _save_rules(data)
    return {"saved": len(payload.rules)}


@app.get("/rules/preview")
def rules_preview(subject: str, body: str):
    # Uses your lightweight keyword classifier from app.rules
    return {"tags": classify_message(subject, body)}


# -------------------------------------------------------------------
# Gmail label utilities
# -------------------------------------------------------------------

class EnsureLabelsPayload(BaseModel):
    labels: List[str]


@app.post("/gmail/ensure-labels")
def ensure_labels(payload: EnsureLabelsPayload):
    gc = get_gmail_client()
    svc = _svc(gc)
    existing = svc.users().labels().list(userId="me").execute().get("labels", [])
    have = {l["name"] for l in existing}
    to_create = [n for n in payload.labels if n not in have]
    for name in to_create:
        svc.users().labels().create(
            userId="me",
            body={"name": name, "labelListVisibility": "labelShow", "messageListVisibility": "show"},
        ).execute()
    return {"created": to_create, "have": sorted(list(have | set(to_create)))}


# -------------------------------------------------------------------
# Message parsing / matching helpers
# -------------------------------------------------------------------

def _text_from_message(msg: Dict[str, Any]) -> str:
    """Extract plain text body (fallback to snippet)."""
    payload = msg.get("payload", {}) or {}
    parts = payload.get("parts") or []
    chunks: List[str] = []
    for p in parts:
        if p.get("mimeType") == "text/plain" and p.get("body", {}).get("data"):
            chunks.append(base64.urlsafe_b64decode(p["body"]["data"]).decode("utf-8", errors="ignore"))
    return "\n".join(chunks) if chunks else msg.get("snippet", "")


def parse_order_id(subject: str, body: str) -> Optional[str]:
    """
    Look for OU-style ids (OU12345), 'order #12345', '#12345', or bare 5+ digits.
    Returns a cleaned string or None.
    """
    text = f"{subject}\n{body}"
    m = re.search(r"\bOU\d{5,}\b", text, flags=re.I)
    if m:
        return m.group(0).upper()
    m = re.search(r"\border\s*#\s*(\d{5,})\b", text, flags=re.I) or re.search(r"#\s*(\d{5,})\b", text, flags=re.I)
    if m:
        return m.group(1)
    m = re.search(r"\b(\d{5,})\b", text)
    if m:
        return m.group(1)
    return None


def lookup_order(order_id: str) -> Optional[dict]:
    """
    Reads data/orders.json and returns the first matching order dict or None.
    """
    path = DATA_DIR / "orders.json"
    if not path.exists():
        return None
    try:
        orders = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None
    for o in orders:
        if o.get("order_id", "").upper() == (order_id or "").upper():
            return o
    return None


def _match_label(body: str, subject: str, rules: Dict[str, Any]) -> Optional[RuleItem]:
    text = f"{subject}\n{body}".lower()
    for r in rules.get("rules", []):
        for kw in r.get("if_any", []):
            if kw.lower() in text:
                return RuleItem(**r)
    return None


# -------------------------------------------------------------------
# Core: process inbox (label + optional auto-reply with order lookup)
# -------------------------------------------------------------------

class ProcessPayload(BaseModel):
    auto_reply: bool = False
    max_messages: int = 25


@app.post("/gmail/process-inbox")
def _extract_name(from_hdr: str) -> str:
    # "Stephen Ponce" <sponce96@icloud.com>
    m = re.match(r'^\s*"?(?P<name>[^"<]+?)"?\s*<(?P<email>[^>]+)>', from_hdr or "")
    if m:
        name = (m.group("name") or "").strip()
        if name:
            return name.split()[0]          # first name
        return (m.group("email") or "").split("@", 1)[0]
    # fallback if it's just an email
    return (from_hdr or "").split("@", 1)[0].replace("<","").replace(">","").strip() or "there"
def process_inbox(payload: ProcessPayload):
    gc = get_gmail_client()
    svc = _svc(gc)
    rules = _load_rules()
    tpls = _load_templates()

    # broadened query so “where’s my package” style phrases are caught
    q = (
        'in:inbox (is:unread OR "order" OR "package" OR "delivery" OR "tracking" '
        'OR "shipment" OR "arrived" OR "missing" OR "unreceived" OR "not received" OR "not arrived")'
    )
    res = svc.users().messages().list(userId="me", q=q, maxResults=payload.max_messages).execute()
    msgs = res.get("messages", []) or []

    processed = labeled = replied = 0

    # cache/ensure labels
    labels = svc.users().labels().list(userId="me").execute().get("labels", [])
    name_to_id = {l["name"]: l["id"] for l in labels}

    def _ensure_label(name: str) -> str:
        if name in name_to_id:
            return name_to_id[name]
        created = svc.users().labels().create(
            userId="me",
            body={"name": name, "labelListVisibility": "labelShow", "messageListVisibility": "show"},
        ).execute()
        name_to_id[name] = created["id"]
        return created["id"]

    for m in msgs:
        full = svc.users().messages().get(userId="me", id=m["id"], format="full").execute()
        headers = {h["name"].lower(): h["value"] for h in full.get("payload", {}).get("headers", [])}
        subj = headers.get("subject", "")
        from_hdr = headers.get("from", "")
        body = _text_from_message(full)

        rule = _match_label(body, subj, rules)
        if rule:
            lid = _ensure_label(rule.apply_label)
            svc.users().messages().modify(
                userId="me", id=m["id"], body={"addLabelIds": [lid], "removeLabelIds": []}
            ).execute()
            labeled += 1

            if payload.auto_reply:
                # Extract "to" from From:
                maddr = re.search(r"<([^>]+)>", from_hdr)
                to_addr = maddr.group(1) if maddr else from_hdr
                friendly = _extract_name(from_hdr)

                # Orders: try to parse/lookup and send a data-driven reply
                if rule.apply_label.lower() == "orders":
                    order_id = parse_order_id(subj, body)
                    info = lookup_order(order_id) if order_id else None

                    if info:
                        subject_out = f"Update on order {info['order_id']}"
                        lines = [
                            f"Hi {friendly},",
                            "",
                            f"Status: {info.get('status', 'Unknown')}",
                        ]
                        if info.get("carrier") and info.get("tracking"):
                            lines.append(f"Carrier: {info['carrier']}")
                            lines.append(f"Tracking: {info['tracking']}")
                        if info.get("last_update"):
                            lines.append(f"Last update: {info['last_update']}")
                        lines.append("")
                        lines.append("— Oubon Support")

                        try:
                            gc.send_simple_email(to=to_addr, subject=subject_out, body="\n".join(lines))
                            replied += 1
                        except Exception:
                            pass
                    else:
                        # fall back to template if no order found
                        tpl = tpls.get(rule.auto_reply_template) or DEFAULT_TPLS.get(rule.auto_reply_template or "")
                        if tpl:
                            try:
                                gc.send_simple_email(
                                    to=to_addr,
                                    subject=f"Re: {subj}" if subj else "Thanks for your message",
                                    body=tpl["body"]
                                        .replace("{{ticket_id}}", full.get("id", ""))
                                        .replace("{{name}}", friendly),
                                )
                                replied += 1
                            except Exception:
                                pass
                else:
                    # Non-orders auto-replies (if template configured)
                    if rule.auto_reply or rule.auto_reply_template:
                        tpl = tpls.get(rule.auto_reply_template) or DEFAULT_TPLS.get(rule.auto_reply_template or "")
                        if tpl:
                            try:
                                gc.send_simple_email(
                                    to=to_addr,
                                    subject=f"Re: {subj}" if subj else "Thanks for your message",
                                    body=tpl["body"]
                                        .replace("{{ticket_id}}", full.get("id", ""))
                                        .replace("{{name}}", friendly),
                                )
                                replied += 1
                            except Exception:
                                pass

        processed += 1

    return {"processed": processed, "labeled": labeled, "replied": replied}


# -------------------------------------------------------------------
# Debug: peek at how messages will be classified/handled
# -------------------------------------------------------------------

@app.get("/debug/peek")
def debug_peek(limit: int = 5):
    gc = get_gmail_client()
    svc = _svc(gc)

    q = (
        'in:inbox (is:unread OR "order" OR "package" OR "delivery" OR "tracking" '
        'OR "shipment" OR "arrived" OR "missing" OR "unreceived" OR "not received" OR "not arrived")'
    )
    res = svc.users().messages().list(userId="me", q=q, maxResults=limit).execute()
    msgs = res.get("messages", []) or []

    labels = svc.users().labels().list(userId="me").execute().get("labels", [])
    name_to_id = {l["name"]: l["id"] for l in labels}

    out = []
    for m in msgs:
        full = svc.users().messages().get(userId="me", id=m["id"], format="full").execute()
        headers = {h["name"].lower(): h["value"] for h in full.get("payload", {}).get("headers", [])}
        subj = headers.get("subject", "")
        body = _text_from_message(full).strip()[:400]

        # You can also try your app.rules helpers here if you prefer:
        # tags = classify_message(subj, body)
        # rule2 = get_rule_for_tags(tags)
        rule = _match_label(body, subj, _load_rules())

        out.append({
            "id": m["id"],
            "subject": subj,
            "preview": body,
            "rule": None if not rule else {
                "apply_label": rule.apply_label,
                "auto_reply_template": rule.auto_reply_template,
                "auto_reply": rule.auto_reply,
            },
            "orders_label_id": name_to_id.get("Orders"),
        })

    return {"q": q, "count": len(out), "items": out}


# -------------------------------------------------------------------
# AI reply demo (not used by processor, but handy)
# -------------------------------------------------------------------

class DraftReq(BaseModel):
    subject: str
    body: str


@app.post("/ai/reply-draft")
def ai_reply_draft(req: DraftReq, settings: Settings = Depends(get_settings)):
    reply = draft_reply(req.subject, req.body, settings=settings)
    return {"draft": reply}
